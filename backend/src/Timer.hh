// Timer.hh --- Break Timer
//
// Copyright (C) 2001 - 2010, 2012, 2013 Rob Caelers <robc@krandor.nl>
// All rights reserved.
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
//

#ifndef TIMER_HH
#define TIMER_HH

#if TIME_WITH_SYS_TIME
# include <sys/time.h>
# include <time.h>
#else
# if HAVE_SYS_TIME_H
#  include <sys/time.h>
# else
#  include <time.h>
# endif
#endif

#include <string>
#include <glib.h>

#include "IActivityMonitor.hh"

class DayTimePred;

enum TimerState
  {
    STATE_INVALID,
    STATE_RUNNING,
    STATE_STOPPED
  };

enum InsensitiveMode
  {
    INSENSITIVE_MODE_FOLLOW_IDLE,
    INSENSITIVE_MODE_IDLE_ON_LIMIT_REACHED,
    INSENSITIVE_MODE_IDLE_ALWAYS
  };

//! Event generated by the timer.
enum TimerEvent
  {
    //! No event occurred.
    TIMER_EVENT_NONE,

    //! The timer was reset back to 0 after the limit was reached.
    TIMER_EVENT_RESET,

    //! The timer was reset back to 0 before the limit was reached.
    TIMER_EVENT_NATURAL_RESET,

    //! The timer reached its limit.
    TIMER_EVENT_LIMIT_REACHED,
  };


//! The Timer class.
/*!
 *  The Timer receives 'active' and 'idle' events from an activity monitor.
 *  Based on these events, the timer will start or stop the clock.
 *
 */
class Timer
{
public:
  typedef boost::shared_ptr<Timer> Ptr;

public:
  static Ptr create();

  // Construction/Destruction.
  Timer();
  virtual ~Timer();

  // Control
  void enable();
  void disable();
  
  void snooze_timer();
  void inhibit_snooze();
  
  void start_timer();
  void stop_timer();
  void reset_timer();
  void restart_insensitive_timer();

  void freeze_timer(bool f);

  // Timer processing.
  TimerEvent process(ActivityState activityState);

  // State inquiry
  gint64 get_elapsed_time() const;
  gint64 get_elapsed_idle_time() const;
  TimerState get_state() const;
  bool is_enabled() const;

  // Auto-resetting.
  void set_auto_reset(int t);
  void set_daily_reset(DayTimePred *daily_reset);
  void set_auto_reset_enabled(bool b);
  bool is_auto_reset_enabled() const;
  gint64 get_auto_reset() const;
  gint64 get_next_reset_time() const; 

  // Limiting.
  void set_limit(int t);
  void set_limit_enabled(bool b);
  bool is_limit_enabled() const;
  gint64 get_limit() const;
  gint64 get_next_limit_time() const;

  // Snoozing.
  void set_snooze(gint64 time);
  gint64 get_snooze() const;

  // Activity sensitivity
  void set_activity_sensitive(bool a);
  bool is_activity_sensitive();
  void set_insensitive_mode(InsensitiveMode mode);

  // Timer ID
  void set_id(std::string id);
  std::string get_id() const;
  
  // State serialization.
  std::string serialize_state() const;
  bool deserialize_state(const std::string &state, int version);
  void set_state(int elapsed, int idle, int overdue = -1);

  gint64 get_total_overdue_time() const;
  void daily_reset_timer();

private:
  void compute_next_limit_time();
  void compute_next_reset_time();
  void compute_next_daily_reset_time();
  
private:
  //! Is this timer enabled ?
  bool timer_enabled;

  //! Is the timer frozen? A frozen timer only counts idle time.
  bool timer_frozen;

  //! State of the state monitor.
  ActivityState activity_state;

  //! State of the timer.
  TimerState timer_state;

  //! Default snooze time
  gint64 snooze_interval;

  //! Don't snooze til next reset or changes.
  bool snooze_inhibited;

  //! Is the timer limit enabled?
  bool limit_enabled;

  //! Timer limit interval.
  gint64 limit_interval;

  //! Is the timer auto reset enabled?
  bool autoreset_enabled;

  //! Automatic reset time interval.
  gint64 autoreset_interval;

  //! Daily auto reset checker (NULL if not used)
  DayTimePred *daily_autoreset;

  //! Elapsed time.
  gint64 elapsed_timespan;

  //! The total elapsed time the last time the limit was reached.
  gint64 elapsed_timespan_at_last_limit;

  //! Elapsed Idle time.
  gint64 elapsed_idle_timespan;

  //! Total overdue time.
  gint64 total_overdue_timespan;

  //! Time when the timer was last started.
  gint64 last_start_time;

  //! Time when the timer was last stopped.
  gint64 last_stop_time;

  //! Time when the timer was last reset.
  gint64 last_reset_time;

  //! Time when the timer was last reset because of a daily reset.
  gint64 last_daily_reset_time;

  //! Next automatic reset time.
  gint64 next_reset_time;

  //! Next daily reset time.
  gint64 next_daily_reset_time;

  //! Next limit time.
  gint64 next_limit_time;

  //! Id of the timer.
  std::string timer_id;

  //!  Is this timer sensitive for activity
  bool activity_sensitive;

  //!
  InsensitiveMode insensitive_mode;
};

#endif // TIMER_HH
