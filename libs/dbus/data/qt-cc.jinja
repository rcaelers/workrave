#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <array>
#include <string>
#include <string_view>

#include "dbus/DBusBindingQt.hh"
#include "dbus/DBusException.hh"
#include "{{ model.include_filename }}.hh"

using namespace workrave::dbus;

//
// Marshaller
//

{% for enum in model.enums %}

{% if enum.condition != '' %}
#if {{ enum.condition }}
{% endif %}

namespace workrave::dbus
{
template<>
struct DBusMarshall<{{ enum.symbol() }}>
{
  static {{ enum.symbol() }} convert(const QVariant &variant)
  {
    const QString &arg = variant.value<QString>();
    {{ enum.symbol() }} value{};
{% for e in enum.values %}
{% if loop.first %}
    if
{%- else %}
    else if
{%- endif %}
 ("{{ e.name }}" == arg)
      {
        value = {{ e.symbol() }};
      }
{% endfor %}
    else
      {
        throw DBusRemoteException()
          << message_info("Type error in enum")
          << error_code_info(DBUS_ERROR_INVALID_ARGS)
          << actual_type_info("{{ enum.name }}");
      }
    return value;
  }
  static void marshall(QDBusArgument &arg, {{ enum.symbol() }} value)
  {
      QString str;
    switch (value)
      {
  {% for e in enum.values %}
      case {{ e.symbol() }}:
        str = "{{ e.name }}";
        break;
  {% endfor %}
      default:
        throw DBusRemoteException()
          << message_info("Type error in enum")
          << error_code_info(DBUS_ERROR_INVALID_ARGS)
          << actual_type_info("{{ enum.name }}");
      }
    arg << str;
  }
  static QVariant convert({{ enum.symbol() }} value)
  {
    QString arg;
    switch (value)
      {
  {% for e in enum.values %}
      case {{ e.symbol() }}:
        arg = "{{ e.name }}";
        break;
  {% endfor %}
      default:
        throw DBusRemoteException()
          << message_info("Type error in enum")
          << error_code_info(DBUS_ERROR_INVALID_ARGS)
          << actual_type_info("{{ enum.name }}");
      }
    return QVariant::fromValue(arg);
  }
};
}

[[maybe_unused]] static QDBusArgument &
operator<<(QDBusArgument &arg, const {{ enum.symbol() }} &data)
{
  DBusMarshall<{{ enum.symbol() }}>::marshall(arg, data);
  return arg;
}

[[maybe_unused]] static const QDBusArgument &
operator>>(const QDBusArgument &arg, {{ enum.symbol() }} &data)
{
  QString value;
  arg >> value;
  data = DBusMarshall<{{ enum.symbol() }}>::convert(value);
  return arg;
}

{% if enum.condition %}
#endif // {{ enum.condition }}
{% endif %}

{% endfor %}

{% for struct in model.structs %}

{% if struct.condition %}
#if {{ struct.condition }}
{% endif %}

namespace workrave::dbus
{
template<>
struct DBusMarshall<{{ struct.symbol() }}>
{
  static {{ struct.symbol() }} convert(const QVariant &variant)
  {
{% set num_expected_fields = struct.fields | length %}
    {{ struct.symbol() }} result;

    const auto arg = variant.value<QDBusArgument>();
    if (arg.currentType() != QDBusArgument::StructureType)
      {
        throw DBusRemoteException()
          << message_info("Incorrect type")
          << error_code_info(DBUS_ERROR_INVALID_ARGS)
          << expected_type_info("{{ struct.name }}");
      }

    arg.beginStructure();
{% for p in struct.fields %}
    if (arg.atEnd())
    {
        throw DBusRemoteException()
          << message_info("Incorrect number of member in struct")
          << error_code_info(DBUS_ERROR_INVALID_ARGS)
          << actual_type_info("{{ struct.name }}");
    }

    try
      {
        result.{{ p.name }} = DBusMarshall<{{ model.get_type(p.type).symbol() }}>::convert(arg.asVariant());
      }
    catch (const DBusRemoteException &e)
      {
        e << field_info("{{ p.name }}");
        throw;
      }
{% endfor %}
    arg.endStructure();
    return result;
  }
  static void marshall(QDBusArgument &arg, {{ struct.symbol() }} value)
  {
    arg.beginStructure();
{% for p in struct.fields %}
    DBusMarshall<{{ model.get_type(p.type).symbol() }}>::marshall(arg, value.{{ p.name }});
{% endfor %}
    arg.endStructure();
  }
  static QVariant convert(const {{ struct.symbol() }} &value)
  {
    QDBusArgument arg;
    marshall(arg, value);
    return QVariant::fromValue(arg);
  }
};
}

[[maybe_unused]] static QDBusArgument &
operator<<(QDBusArgument &arg, const {{ struct.symbol() }} &data)
{
  DBusMarshall<{{ struct.symbol() }}>::marshall(arg, data);
  return arg;
}

[[maybe_unused]] static const QDBusArgument &
operator>>(const QDBusArgument &arg, {{ struct.symbol() }} &data)
{
  QVariant value = arg.asVariant();
  data = DBusMarshall<{{ struct.symbol() }}>::convert(value);
  return arg;
}


{% if struct.condition %}
#endif // {{ struct.condition }}
{% endif %}

{% endfor %}

//
// Interfaces
//

{% for interface in model.interfaces %}

//
// Interface {{ interface.name }}
//

{% if interface.condition != '' %}
#if {{ interface.fcondition }}
{% endif %}

{% if interface.namespace_list | length > 0 %}
namespace {{ interface.namespace_list | join("::") }} // interface {{ interface.name }} namespace
{
{% endif -%}

class {{ interface.qname }}_Stub : public DBusBindingQt, public {{ interface.qname }}
{
private:
  using DBusMethodPointer = void ({{ interface.qname }}_Stub::*)(void *object, const QDBusMessage &message, const QDBusConnection &connection);

  struct DBusMethod
  {
    std::string_view name;
    DBusMethodPointer fn;
  };

  bool call(void *object, const QDBusMessage &message, const QDBusConnection &connection) override;

  std::string_view get_interface_introspect() override
  {
    return interface_introspect;
  }

public:
  explicit {{ interface.qname }}_Stub(std::shared_ptr<IDBus> dbus);
  ~{{ interface.qname }}_Stub() override = default;

{% for m in interface.signals %}
  void {{ m.qname }}(const std::string &path
  {% for p in m.params %}
    {% if p.hint == [] %}
      , {{ interface.get_type(p.type).symbol() }} {{ p.name }}
    {% elif 'ptr' in p.hint %}
      , {{ interface.get_type(p.type).symbol() }} *{{ p.name }}
    {% elif 'ref' in p.hint %}
      , {{ interface.get_type(p.type).symbol() }} &{{ p.name }}
    {% endif %}
  {% endfor %}
  ) override;
{% endfor %}


private:
{% for m in interface.methods %}
  void {{ m.qname }}(void *object, const QDBusMessage &message, const QDBusConnection &connection);
{% endfor %}

  static constexpr std::array<DBusMethod, {{ interface.methods | length}}> method_table =
  { {
{% for method in interface.methods %}
      {.name="{{ method.name }}", .fn=&{{ interface.qname }}_Stub::{{ method.qname }}} ,
{% endfor %}
  } };
  static constexpr std::string_view interface_introspect =
  "  <interface name=\"{{ interface.name }}\">\n"
{% for method in interface.methods %}
  "    <method name=\"{{ method.qname }}\">\n"
  {% for p in method.params %}
    {% if p.direction == 'in' or p.direction == 'out' %}
  "      <arg type=\"{{ p.sig() }}\" name=\"{{ p.name }}\" direction=\"{{ p.direction }}\" />\n"
    {% endif %}
  {% endfor %}
  "    </method>\n"
{% endfor %}
  {% for signal in interface.signals %}
  "    <signal name=\"{{ signal.qname }}\">\n"
    {% for p in signal.params %}
  "      <arg type=\"{{ p.sig() }}\" name=\"{{ p.name }}\" />\n"
    {% endfor %}
  "    </signal>\n"
  {% endfor %}
  "  </interface>\n";
};


{{ interface.qname }} *{{ interface.qname }}::instance(std::shared_ptr<::workrave::dbus::IDBus> dbus)
{
  {{ interface.qname }}_Stub *iface = nullptr;
  DBusBinding *binding = dbus->find_binding("{{ interface.name }}");

  if (binding != nullptr)
    {
      iface = dynamic_cast<{{ interface.qname }}_Stub *>(binding);
    }

  return iface;
}

{{ interface.qname }}_Stub::{{ interface.qname }}_Stub(std::shared_ptr<IDBus> dbus)
  : DBusBindingQt(dbus)
{
}

bool
{{ interface.qname }}_Stub::call(void *object, const QDBusMessage &message, const QDBusConnection &connection)
{
  std::string method_name = message.member().toStdString();
  constexpr std::array<DBusMethod, {{ interface.methods | length}}> table = method_table;
  for (const auto &method : table)
    {
      if (method_name == method.name)
        {
          DBusMethodPointer ptr = method.fn;
          if (ptr != nullptr)
            {
              (this->*ptr)(object, message, connection);
            }
          return true;
        }
    }
  throw DBusRemoteException()
    << message_info("Unknown method")
    << error_code_info(DBUS_ERROR_UNKNOWN_METHOD)
    << method_info(method_name)
    << interface_info("{{ interface.name }}");
}

//
// Interface {{ interface.name }} methods
//

{% for method in interface.methods %}

//
// Interface {{ interface.name }} method {{ method.name }}
//

void
{{ interface.qname }}_Stub::{{ method.name }}(void *object, const QDBusMessage &message, const QDBusConnection &connection)
{
{% if method.condition != '' %}
#if {{ method.condition }}
{% endif %}
  try
    {
{% if method.symbol() != "" %}
      auto *dbus_object = static_cast<{{ interface.symbol() }} *>(object);
{% else %}
      (void) object;
{% endif %}

{% for p in method.params %}
      {{ interface.get_type(p.type).symbol() }} p_{{ p.name }}
  {%- if p.direction == 'bind' %}
      = {{ p.bind }};
  {%- elif p.direction == 'sender' %}
      = sender;
  {%- else -%}
      {};
  {% endif %}
{% endfor %}

      auto num_in_args = message.arguments().size();
      if (num_in_args != {{ method.num_in_args }})
        {
          throw DBusRemoteException()
            << message_info("Incorrecy number of in-paraeters")
            << error_code_info(DBUS_ERROR_INVALID_ARGS)
            << method_info("{{ method.name }}")
            << interface_info("{{ interface.name }}");
        }

{% for arg in method.params if arg.direction == 'in' %}
      p_{{ arg.name }} = DBusMarshall<{{ interface.get_type(arg.type).symbol() }}>::convert(message.arguments().at({{ loop.index0 }}));
{% endfor %}

{% if method.symbol() != "" %}
  {% if method.return_type() != 'void' %}
      p_{{ method.return_name() }} =
  {%- endif %}
  dbus_object->{{ method.symbol() }}(
{% set comma = joiner(",") %}
  {% for p in method.params %}
    {% if 'return' not in p.hint %}
      {% if 'ptr' in p.hint %}
        {{ comma() }} &p_{{ p.name }}
      {% else %}
        {{ comma() }} p_{{ p.name }}
      {% endif %}
    {% endif %}
  {% endfor %}
      );
{% endif %}

      QDBusMessage reply = message.createReply();

{% if method.num_out_args > 0 %}
  {% for arg in method.params: %}
    {% if arg.direction == 'out' %}
      reply << DBusMarshall<{{ interface.get_type(arg.type).symbol() }}>::convert(p_{{ arg.name }});
    {% endif %}
  {% endfor %}
{% endif %}

      bool rc = connection.send(reply);
      if (!rc)
        {
          throw DBusRemoteException()
            << message_info("Failed to send reply")
            << error_code_info(DBUS_ERROR_FAILED)
            << method_info("{{ method.name }}")
            << interface_info("{{ interface.name }}");
        }
    }
  catch (const DBusRemoteException &e)
    {
      e << method_info("{{ method.name }}")
        << interface_info("{{ interface.name }}");
      throw;
    }

{% if method.condition != '' %}
#else
  message.createErrorReply(QDBusError::UnknownMethod,
                          "This method is unavailable in current configuration");
#endif
{% endif %}
}


{% endfor %}

//
// Interface {{ interface.name }} signals
//

{% for signal in interface.signals %}

//
// Interface {{ interface.name }} signal {{ signal.name }}
//

void {{ interface.qname }}_Stub::{{ signal.qname }}(const std::string &path
  {% for p in signal.params %}
    {% if p.hint == [] %}
      , {{ interface.get_type(p.type).symbol() }} p_{{ p.name }}
    {% elif 'ptr' in p.hint %}
      , {{ interface.get_type(p.type).symbol() }} *p_{{ p.name }}
    {% elif 'ref' in p.hint %}
      , {{ interface.get_type(p.type).symbol() }} &p_{{ p.name }}
    {% endif %}
  {% endfor %}
)
{
  QDBusMessage sig = QDBusMessage::createSignal(QString::fromStdString(path), "{{ interface.name }}", "{{ signal.name }}");

{% if signal.params|length > 0 %}
  {% for arg in signal.params: %}
    {% if 'ptr' in arg.hint %}
      sig << DBusMarshall<{{ interface.get_type(arg.type).symbol() }}>::convert(* p_{{ arg.name }});
    {% else %}
      sig <<  DBusMarshall<{{ interface.get_type(arg.type).symbol() }}>::convert(p_{{ arg.name }});
    {% endif %}
  {% endfor %}
{% endif %}

  IDBusPrivateQt::Ptr priv = std::dynamic_pointer_cast<IDBusPrivateQt>(dbus);
  priv->get_connection().send(sig);
}

{% endfor %}

{% if interface.namespace_list | length >  0%}
} // namespace {{ interface.namespace_list | join("::") }}
{% endif %}

{% if interface.condition != '' %}
 #endif // {{ interface.condition }}
{% endif %}

{% endfor %}

void init_{{ model.name }}(std::shared_ptr<IDBus> dbus)
{

{% for interface in model.interfaces %}
{% if interface.condition != '' %}
#if {{ interface.condition }}
{% endif %}
  dbus->register_binding("{{ interface.name }}", new {% for ns in interface.namespace_list %}{{ ns }}::{% endfor %}{{ interface.qname }}_Stub(dbus));
{% if interface.condition != '' %}
#endif // {{ interface.condition }}
{% endif %}
{% endfor %}

{% for struct in model.structs %}
{% if struct.condition %}
#if {{ struct.condition }}
{% endif %}
  qDBusRegisterMetaType<{{ struct.symbol() }}>();
{% if struct.condition %}
#endif // {{ struct.condition }}
{% endif %}
{% endfor %}

{% for enum in model.enums %}
{% if enum.condition != '' %}
#if {{ enum.condition }}
{% endif %}
  qDBusRegisterMetaType<{{ enum.symbol() }}>();
{% if enum.condition %}
#endif // {{ enum.condition }}
{% endif %}
{% endfor %}

}

{% for ns in model.namespace_list|reverse %}
} // namespace {{ ns }}
{% endfor %}
