#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <array>
#include <string>
#include <string_view>

#include "dbus/DBusBindingQt.hh"
#include "dbus/DBusException.hh"
#include "{{ model.include_filename }}.hh"

using namespace workrave::dbus;

//
// Marshaller
//

{% for enum in model.enums %}

{% if enum.condition != '' %}
#if {{ enum.condition }}
{% endif %}

[[maybe_unused]] static QDBusArgument &
operator<<(QDBusArgument &arg, const {{ enum.symbol() }} &data)
{
  std::string value;
  switch (data)
    {
{% for e in enum.values %}
    case {{ e.symbol() }}:
      value = "{{ e.name }}";
      break;
{% endfor %}
    default:
      throw DBusRemoteException()
        << message_info("Type error in enum")
        << error_code_info(DBUS_ERROR_INVALID_ARGS)
        << actual_type_info("{{ enum.name }}");
    }

  arg << QString::fromStdString(value);
  return arg;
}

[[maybe_unused]] static const QDBusArgument &
operator>>(const QDBusArgument &arg, {{ enum.symbol() }} &data)
{
  QString value;
  arg >> value;

{% for e in enum.values %}
  {% if loop.first %}
  if
  {%- else %}
  else if
  {%- endif %}
  ("{{ e.name }}" == value)
    {
      data = {{ e.symbol() }};
    }
{% endfor %}
  else
    {
      throw DBusRemoteException()
        << message_info("Type error in enum")
        << error_code_info(DBUS_ERROR_INVALID_ARGS)
        << actual_type_info("{{ enum.name }}");
    }
  return arg;
}

{% if enum.condition %}
#endif // {{ enum.condition }}
{% endif %}

{% endfor %}


{% for struct in model.structs %}

{% if struct.condition %}
#if {{ struct.condition }}
{% endif %}
[[maybe_unused]] static QDBusArgument &
operator<<(QDBusArgument &arg, const {{ struct.symbol() }} &data)
{
  arg.beginStructure();
{% for p in struct.fields %}
  arg.appendVariant({{ model.get_type(p.type).value_to_internal('data.' + p.name) }});
{% endfor %}
  arg.endStructure();
  return arg;
}

[[maybe_unused]] static const QDBusArgument &
operator>>(const QDBusArgument &arg, {{ struct.symbol() }} &data)
{
  arg.beginStructure();
{% for p in struct.fields %}
{% if model.get_type(p.type).value_from_internal('x') == 'x' %}
    arg >> data.{{ p.name }};
{% else %}
    {{ model.get_type(p.type).symbol_int() }} t_{{ p.name }} {};
    arg >> t_{{ p.name }};
    data.{{ p.name }} = {{ model.get_type(p.type).value_from_internal('t_' + p.name) }};
{% endif %}
{% endfor %}
  arg.endStructure();
  return arg;
}

{% if struct.condition %}
#endif // {{ struct.condition }}
{% endif %}

{% endfor %}

//
// Interfaces
//

{% for interface in model.interfaces %}

//
// Interface {{ interface.name }}
//

{% if interface.condition != '' %}
#if {{ interface.fcondition }}
{% endif %}

{% if interface.namespace_list | length > 0 %}
namespace {{ interface.namespace_list | join("::") }} // interface {{ interface.name }} namespace
{
{% endif -%}

class {{ interface.qname }}_Stub : public DBusBindingQt, public {{ interface.qname }}
{
private:
  using DBusMethodPointer = void ({{ interface.qname }}_Stub::*)(void *object, const QDBusMessage &message, const QDBusConnection &connection);

  struct DBusMethod
  {
    std::string_view name;
    DBusMethodPointer fn;
  };

  bool call(void *object, const QDBusMessage &message, const QDBusConnection &connection) override;

  std::string_view get_interface_introspect() override
  {
    return interface_introspect;
  }

public:
  explicit {{ interface.qname }}_Stub(IDBus::Ptr dbus);
  ~{{ interface.qname }}_Stub() override = default;

{% for m in interface.signals %}
  void {{ m.qname }}(const std::string &path
  {% for p in m.params %}
    {% if p.hint == [] %}
      , {{ interface.get_type(p.type).symbol() }} {{ p.name }}
    {% elif 'ptr' in p.hint %}
      , {{ interface.get_type(p.type).symbol() }} *{{ p.name }}
    {% elif 'ref' in p.hint %}
      , {{ interface.get_type(p.type).symbol() }} &{{ p.name }}
    {% endif %}
  {% endfor %}
  ) override;
{% endfor %}


private:
{% for m in interface.methods %}
  void {{ m.qname }}(void *object, const QDBusMessage &message, const QDBusConnection &connection);
{% endfor %}

  static constexpr std::array<DBusMethod, {{ interface.methods | length}}> method_table =
  { {
{% for method in interface.methods %}
      {.name="{{ method.name }}", .fn=&{{ interface.qname }}_Stub::{{ method.qname }}} ,
{% endfor %}
  } };
  static constexpr std::string_view interface_introspect =
  "  <interface name=\"{{ interface.name }}\">\n"
{% for method in interface.methods %}
  "    <method name=\"{{ method.qname }}\">\n"
  {% for p in method.params %}
    {% if p.direction == 'in' or p.direction == 'out' %}
  "      <arg type=\"{{ p.sig() }}\" name=\"{{ p.name }}\" direction=\"{{ p.direction }}\" />\n"
    {% endif %}
  {% endfor %}
  "    </method>\n"
{% endfor %}
  {% for signal in interface.signals %}
  "    <signal name=\"{{ signal.qname }}\">\n"
    {% for p in signal.params %}
  "      <arg type=\"{{ p.sig() }}\" name=\"{{ p.name }}\" />\n"
    {% endfor %}
  "    </signal>\n"
  {% endfor %}
  "  </interface>\n";
};


{{ interface.qname }} *{{ interface.qname }}::instance(std::shared_ptr<::workrave::dbus::IDBus> dbus)
{
  {{ interface.qname }}_Stub *iface = nullptr;
  DBusBinding *binding = dbus->find_binding("{{ interface.name }}");

  if (binding != nullptr)
    {
      iface = dynamic_cast<{{ interface.qname }}_Stub *>(binding);
    }

  return iface;
}

{{ interface.qname }}_Stub::{{ interface.qname }}_Stub(IDBus::Ptr dbus)
  : DBusBindingQt(dbus)
{
}

bool
{{ interface.qname }}_Stub::call(void *object, const QDBusMessage &message, const QDBusConnection &connection)
{
  std::string method_name = message.member().toStdString();
  constexpr std::array<DBusMethod, {{ interface.methods | length}}> table = method_table;
  for (const auto &method : table)
    {
      if (method_name == method.name)
        {
          DBusMethodPointer ptr = method.fn;
          if (ptr != nullptr)
            {
              (this->*ptr)(object, message, connection);
            }
          return true;
        }
    }
  throw DBusRemoteException()
    << message_info("Unknown method")
    << error_code_info(DBUS_ERROR_UNKNOWN_METHOD)
    << method_info(method_name)
    << interface_info("{{ interface.name }}");
}

//
// Interface {{ interface.name }} methods
//

{% for method in interface.methods %}

//
// Interface {{ interface.name }} method {{ method.name }}
//

void
{{ interface.qname }}_Stub::{{ method.name }}(void *object, const QDBusMessage &message, const QDBusConnection &connection)
{
{% if method.condition != '' %}
#if {{ method.condition }}
{% endif %}
  try
    {
{% if method.symbol() != "" %}
      auto *dbus_object = static_cast<{{ interface.symbol() }} *>(object);
{% else %}
      (void) object;
{% endif %}

{% for p in method.params %}
      {{ interface.get_type(p.type).symbol() }} p_{{ p.name }}
  {%- if p.direction == 'bind' %}
      = {{ p.bind }};
  {%- elif p.direction == 'sender' %}
      = sender;
  {%- else -%}
      {};
  {% endif %}
{% endfor %}

      auto num_in_args = message.arguments().size();
      if (num_in_args != {{ method.num_in_args }})
        {
          throw DBusRemoteException()
            << message_info("Incorrecy number of in-paraeters")
            << error_code_info(DBUS_ERROR_INVALID_ARGS)
            << method_info("{{ method.name }}")
            << interface_info("{{ interface.name }}");
        }

{% for arg in method.params if arg.direction == 'in' %}
      p_{{ arg.name }} = variant_to_value<{{ interface.get_type(arg.type).symbol() }}> (message.arguments().at({{ loop.index0 }}));
{% endfor %}

{% if method.symbol() != "" %}
  {% if method.return_type() != 'void' %}
      p_{{ method.return_name() }} =
  {%- endif %}
  dbus_object->{{ method.symbol() }}(
{% set comma = joiner(",") %}
  {% for p in method.params %}
    {% if 'return' not in p.hint %}
      {% if 'ptr' in p.hint %}
        {{ comma() }} &p_{{ p.name }}
      {% else %}
        {{ comma() }} p_{{ p.name }}
      {% endif %}
    {% endif %}
  {% endfor %}
      );
{% endif %}

      QDBusMessage reply = message.createReply();

{% if method.num_out_args > 0 %}
  {% for arg in method.params: %}
    {% if arg.direction == 'out' %}
      reply << value_to_variant<{{ interface.get_type(arg.type).symbol() }}> (p_{{ arg.name }});
    {% endif %}
  {% endfor %}
{% endif %}

      connection.send(reply);
    }
  catch (const DBusRemoteException &e)
    {
      e << method_info("{{ method.name }}")
        << interface_info("{{ interface.name }}");
      throw;
    }

{% if method.condition != '' %}
#else
  message.createErrorReply(QDBusError::UnknownMethod,
                          "This method is unavailable in current configuration");
#endif
{% endif %}
}


{% endfor %}

//
// Interface {{ interface.name }} signals
//

{% for signal in interface.signals %}

//
// Interface {{ interface.name }} signal {{ signal.name }}
//

void {{ interface.qname }}_Stub::{{ signal.qname }}(const std::string &path
  {% for p in signal.params %}
    {% if p.hint == [] %}
      , {{ interface.get_type(p.type).symbol() }} p_{{ p.name }}
    {% elif 'ptr' in p.hint %}
      , {{ interface.get_type(p.type).symbol() }} *p_{{ p.name }}
    {% elif 'ref' in p.hint %}
      , {{ interface.get_type(p.type).symbol() }} &p_{{ p.name }}
    {% endif %}
  {% endfor %}
)
{
  QDBusMessage sig = QDBusMessage::createSignal(QString::fromStdString(path), "{{ interface.name }}", "{{ signal.name }}");

{% if signal.params|length > 0 %}
  {% for arg in signal.params: %}
    {% if 'ptr' in arg.hint %}
      sig << value_to_variant<{{ interface.get_type(arg.type).symbol() }}> (* p_{{ arg.name }});
    {% else %}
      sig <<  value_to_variant<{{ interface.get_type(arg.type).symbol() }}> (p_{{ arg.name }});
    {% endif %}
  {% endfor %}
{% endif %}

  IDBusPrivateQt::Ptr priv = std::dynamic_pointer_cast<IDBusPrivateQt>(dbus);
  priv->get_connection().send(sig);
}

{% endfor %}

{% if interface.namespace_list | length >  0%}
} // namespace {{ interface.namespace_list | join("::") }}
{% endif %}

{% if interface.condition != '' %}
 #endif // {{ interface.condition }}
{% endif %}

{% endfor %}

void init_{{ model.name }}(IDBus::Ptr dbus)
{
{% for interface in model.interfaces %}
{% if interface.condition != '' %}
#if {{ interface.condition }}
{% endif %}
  dbus->register_binding("{{ interface.name }}", new {% for ns in interface.namespace_list %}{{ ns }}::{% endfor %}{{ interface.qname }}_Stub(dbus));
{% if interface.condition != '' %}
#endif // {{ interface.condition }}
{% endif %}
{% endfor %}

{% for struct in model.structs %}
{% if struct.condition %}
#if {{ struct.condition }}
{% endif %}
  qDBusRegisterMetaType<{{ struct.symbol() }}>();
{% if struct.condition %}
#endif // {{ struct.condition }}
{% endif %}
{% endfor %}

{% for enum in model.enums %}
{% if enum.condition != '' %}
#if {{ enum.condition }}
{% endif %}
  qDBusRegisterMetaType<{{ enum.symbol() }}>();
{% if enum.condition %}
#endif // {{ enum.condition }}
{% endif %}
{% endfor %}
}

{% for ns in model.namespace_list|reverse %}
} // namespace {{ ns }}
{% endfor %}
